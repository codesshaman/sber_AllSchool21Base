Классические задачи биоинформатики 

Реализация проекта DNA Analyzer.

	
## Contents

1. [Chapter I](#chapter-i) 
    
    1.1. [Introduction](#introduction)
2. [Chapter II](#chapter-ii) 
    
    2.1. [Information](#information)
3. [Chapter III](#chapter-iii) 
    
    3.1. [Part 1](#part-1-реализация-проекта-exact-dna-search)  
	3.2. [Part 2](#part-2-реализация-проекта-nw-sequence-alignment)  
	3.3. [Part 3](#part-3-соответствие-регулярным-выражениям)  
	3.4. [Part 4](#part-4-k-подобные-строки)  
	3.5. [Part 5](#part-5-дополнительно-минимальная-оконная-подстрока)  


## Chapter I



## Introduction

В данном проекте вам предстоит познакомиться с классическими задачами биоинформатики -- поиском подстроки и выравниванием последовательностей, а также прочими алгоритмами обработки строк.


## Chapter II

## Information

Важной частью современной биоинформатики является анализ молекулярных последовательностей. Последовательностями называют строки над произвольным фиксированным алфавитом, например над алфавитом `{ A, C, G, T}` (последовательности ДНК). Вот примеры последовательностей ДНК, являющиеся частями вируса ВИЧ:

```
GGTCTCTCTGGTTAGACCAGATCTGAGC
CTGAGCCTGGGAGCTCTCTGGCTAACTAGGGAACCCACTG
AAGCCTCAAT
```

### Поиск подстроки

В анализе молекулярных последовательностей постоянно необходимо так или иначе сравнивать последовательности друг с другом. Например, бывает необходимо определить _точное совпадение_ двух строк, т.е. посимвольное совпадение строк одинакового размера. Более сложным, но реалистичным случаем является задача поиска подстроки, то есть поиска всех вхождений короткой строки (_needle_, \"иголка\") длины `m` в большую строку (_hay_, \"сено\") длины `n`, `m <= n`. Помимо биоинформатики, задача поиска подстроки в разных вариациях повсеместно встречается в различных задачах _полнотекстового поиска_.

> Пример: в строку `А роза упала на лапу Азора` подстрока `ла` входит дважды, на позицииях 11 и 17.

> Пример: относительно короткая последовательность вируса ВИЧ, состоящая приблизительно из десяти тысяч нуклеотидов (полностью посмотреть ее можно [здесь](https://www.ncbi.nlm.nih.gov/nuccore/AF033819)), содержит два вхождения строки `AAGCCTCAAT`, состоящей из десяти нуклеотидов.

Наивные решения поиска подстроки эффективны, если строки достигают в размере тысяч символов; для строк размеров в миллионы и более символов, а также для массированного поиска большого количества запросов, brute-force алгоритмы могут быть слишком медленны. Эффективные алгоритмы поиска подстроки не вполне тривиальны; одним из простых, но относительно эффективных алгоритмов является алгоритм Рабина-Карпа. Этот алгоритм основан на идее  _хеширования_ подстрок длины `m`, то есть вычисления некоторой функции, которая каждой строке ставит в соответствие некоторое число (хеш). Совпадение хеша для подстроки из \"сена\" с хешом \"иголки\" потенциально указывает на вхождение подстроки. Алгоритм превосходит наивные решения для входных данных достаточного размера, если хеш некоторой подстроки можно подсчитать, зная хеш подстроки, идущей перед ней.

### Выравнивание последовательностей

Молекулярные последовательности эволюционируют и изменяются со временем. В результате мутаций и других эволюционных событий, последовательности близких организмов со временем эволюционно отдаляются друг от друга и становятся все менее схожи. Для сравнения неидеально совпадающих последовательностей, алгоритмов точного поиска недостаточно; чтобы сопоставлять такие последовательности, применяют _выравнивание_. Выравниванием двух последовательностей называют их запись одну под другой, при которой в обе последовательности внесены дополнительные \"пробелы\", или \"гэпы\". Эти гэпы расставлены таким образом, чтобы стоящие друг под другом буквы последовательсностей совпадали. Например, выравнивание двух последовательностей `GGGCGACACTCCACCATAGA` и `GGCGACACCCACCATACAT` (небольшие кусочки из начала геномов двух версий вируса гепатита C), может выглядеть так:

```
GGGCGACACTCCACCATAGA-
|| |||||| |||||||| |
GG-CGACAC-CCACCATACAT
```

Заметьте, что двум последовательностям может соответствовать большое число разных выравниваний (с разным количество совпадающих позиций). С биологической точки зрения выравнивание помогает определить те позиции в последовательностях, которые наиболее вероятно являются гомологичными, то есть имеющими общее эволюционное происхождение. В учебных целях мы можем полагать, что целью выравнивания является максимизация количества совпадающих символов в выравнивании и минимизация несовпадающих. Классическим решением данной задачи является алгоритм Нидлмана-Вунша, предложенный в 1970 году и основанный на идее динамического программирования. Данный алгоритм полагается на функцию \"похожести\", которая оценивает \"стоимость\" (\"скор\" от англ. \"score\") совпадения или не совпадения симоволов, записанных друг под другом, и максимизирует общую \"похожесть\" выравнивания.

```
Пример. Стоимость совпадения 1, стоимость несовпадения -1, стоимость гэпа -2. Тогда выравнивание из предыдущего примера достигает общей стоимости 10: 17 совпадающий символов, 1 несовпадающий, 3 гэпа.
```

Продвинутые версии этого алгоритма используют матрицы похожести, где стоимость совпадений и несовпадений может различаться для разных пар символов. 


## Chapter III

**Общие** указания для выполнения всех частей:
- Программа должна быть разработана на языке C++ стандарта C++17
- Код программы должен находиться в папке src
- Не использовать устаревшие и выведенные из употребления конструкции языка и библиотечные функции
- Предусмотреть Makefile для сборки библиотеки и тестов (с целями all, clean, tests, app)
- Должно быть обеспечено полное покрытие unit-тестами всех функций/методов, используемых при реализации каждого задания
- У программы должен быть предусмотрен консольный интерфейс

## Part 1. Реализация проекта Exact DNA search

Разработать программу для полнотекстового поиска при помощи **алгоритма Рабина-Карпа**. 
    
Программа принимает на вход *два* файла. Они содержат последовательности `a` и `b` длины `n <= 10000` и `m <= 100` соответственно, `m <= n`. Выходом программы является список позиций строки `a`, на которых `b` входит в `a`.

Пример входа: 
    
Файл `datasets/HIV-1_AF033819.3.txt` и файл со следующим содержимым:
```
AAGCCTCAATAAAGCTT
```

Пример выхода:
```
65 9150 9182
```

#### Проверка времени выполнения и потребления памяти

На Unix-like операционных системах есть утилита `/usr/bin/time` (не путать с командой `time` в `bash`). Проверить время работы и потребление программы можно при помощи следующей команды:
```
/usr/bin/time -v PROGRAM
```
где `PROGRAM` соответствует названию исполняемого файла. Вывод `/usr/bin/time` может выглядеть приблизительно так:
```
	Command being timed: \"./nw\"
	User time (seconds): 0.00
	System time (seconds): 0.00
	Percent of CPU this job got: 75%
	Elapsed (wall clock) time (h:mm:ss or m:ss): 0:00.00
	Average shared text size (kbytes): 0
	Average unshared data size (kbytes): 0
	Average stack size (kbytes): 0
	Average total size (kbytes): 0
	Maximum resident set size (kbytes): 3284
	Average resident set size (kbytes): 0
	Major (requiring I/O) page faults: 0
	Minor (reclaiming a frame) page faults: 137
	Voluntary context switches: 1
	Involuntary context switches: 0
	Swaps: 0
	File system inputs: 0
	File system outputs: 0
	Socket messages sent: 0
	Socket messages received: 0
	Signals delivered: 0
	Page size (bytes): 4096
	Exit status: 0
```
Вас интересует время (`Elapsed (wall clock) time`) и память (`Maximum resident set size (kbytes)`).

Максимальное время работы: 1 сек 
    
Максимальное потребление памяти: 128 Мб

## Part 2. Реализация проекта NW sequence alignment

### Part 2.1 Вычисление оптимального скора

Разработать программу для выравнивания двух последовательностей над алфавитом `{A, C, G, T}`. 
    
Входом программы является файл с *тремя* строчками. Первая строка содержит три числа - стоимость совпадения, несовпадения и гэпа. Две следующие строки -- последовательности для выравнивания. Выходом программы является *одно* число -- значение скора для наиболее оптимального выравнивания. 

Пример ввода:
```
1 -1 -2
GGGCGACACTCCACCATAGA
GGCGACACCCACCATACAT
```

Пример вывода:
```
10
```

### Part 2.2 Восстановление оптимального выравнивания

Добавить в программу восстановление оптимального выравнивания, для которого достигается максимальный скор. Выходом программы является значение максимального скора, а под ним -- запись двух строк одна под другой с внесенными в строки гэпами. Совпадающие символы на одинаковых позициях отмечаются вертикальной чертой.

Пример вывода:
```
10
GGGCGACACTCCACCATAGA-
|| |||||| |||||||| |
GG-CGACAC-CCACCATACAT
```

#### Проверка времени выполнения и потребления памяти

См. инструкции к [первой задаче](#part-1-реализация-проекта-exact-dna-search).

Максимальное время работы: 1 сек 
    
Максимальное потребление памяти: 128 Мб

## Part 3. Соответствие регулярным выражениям

Разработать программу для проверки соответствия последовательности над алфавитом `{A, C, G, T}` регулярному выражению. 
    
Входом программы является файл с *двумя* строчками. Первая строка содержит последовательность, для которой будет проверяться соответствие. Вторая строка содержит паттерн, содержащий символы из алфавита и следующие символы:
- `.` -- соответствует любому отдельному символу из алфавита;
- `?` -- соответствует любому отдельному символу из алфавита или отсутствию символа;
- `+` -- соответствует нулю или более повторений предыдущего элемента;
- `*` -- соответствует любой последовательности символов из алфавита или отсутствию символов.

Выходом программы является *Истина*/*Ложь* - соответствует ли заданная последовательность паттерну.

Пример ввода:
```
GGCGACACCCACCATACAT
G?G*AC+A*A.
```

Пример вывода:
```
True
```

**При выполнении этой части запрещено использовать готовые библиотеки для работы с регулярными выражениями, такие как _regex_ или _PCRE_**

## Part 4. K-подобные строки

Строки s1 и s2 k-подобны (для некоторого неотрицательного целого числа *k*), если возможно поменять местами две буквы в s1 ровно *k* раз так, чтобы результирующая строка была равна s2.

Разработать программу для проверки k-подобия двух последовательностей над алфавитом `{A, C, G, T}`. 
    
Входом программы является файл с *двумя* строчками. Выходом программы является наименьшее *k*, для которого s1 и s2 k-подобны. Если строки не являются анаграммами, вывести сообщение об ошибке.

Пример ввода:
```
GGCGACACC
AGCCGCGAC
```

Пример вывода:
```
3
```


## Part 5. Дополнительно. Минимальная оконная подстрока

Подстрока - это непрерывная последовательность символов внутри строки.

Разработать программу для минимальной оконной подстроки для последовательности над алфавитом `{A, C, G, T}`. 
    
Входом программы является файл с *двумя* строчками s и t. Оконной подстрокой строки s называется подстрока, содержащая все символы, входящие в строку t (включая дубликаты).
Выходом программы является оконная подстрока минимальной длины. Если оконной подстроки нет, вернуть пустую строку.

Пример ввода:
```
GGCGACACCCACCATACAT
TGT
```

Пример вывода:
```
GACACCCACCATACAT
```

*Пояснение:*

Подстрока, являющаяся результатом, должна содержать символы `T`, `G`, `T`. Подходящими подстроками являются следующие:
```
GACACCCACCATACAT
CGACACCCACCATACAT
GCGACACCCACCATACAT
GGCGACACCCACCATACAT
```

При этом результатом является подстрока _минимальной_ длины, поэтому выбираем первый вариант.
